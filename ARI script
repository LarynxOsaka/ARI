########################################################################
form ARI based on SFEEDS ver.1 (cs＋sv)
#sample name　= yyyymmddXXX0000F(orM)_cs / yyyymmddXXX0000(orM)_sv
comment Object number of sound files.          Continuous speech           Sustained vowel
real left_Sound_No.
real right_Sound_No.
 real   number_of_patients　1

comment ▼Frame length, Distance between frame centres
　positive　frame_length　0.1
　real　time_step　0.0033
comment ▼Unified average intensity of samples
  boolean intensity_resample 1
  positive   avg_int  70

comment ▼Differential value of dB judged as a silent frame
  real   noLoud_lower_than_allsample 30
comment ▼Differential values of dB determined as frames containing harmonics
  real   noHarmonics_lower_than_frame 20

comment ▼SubharmonicsDraw frames to search---------------------------------------
  boolean draw_subh_search_frame 1

comment ▼DualOscillator peak threshold (dB)
      positive　　biphonationPeakdBthreshold　　5
       positive　　subharmonic3PeakdBthreshold　　5
       positive　　subharmonic2PeakdBthreshold 　5
comment ▼Quantification Preservation
sentence Title_of_table Table_of_SUBHARMONICS_Index
#sentence Save_directory C:\Apps\Praat\Result
sentence Save_directory /Users/username/Desktop/foldername/filemame
comment ▼Drawing the calculation results as a figure
  boolean draw_Results 1
comment ▼Spectrogram storage
    #sentence Save_directory C:\Apps\Praat\Result
    sentence Save_directory /Users/username/Desktop/Result
endform
########################################################################

d = 10
dd = 10
ddd = 10

######Text output of table of contents items#######
echo FileName 	ARI 	ABI 	chaoticNoise_Power_of_all 	superSubharmonics_Power_of_all 	one_3rdSubharmonics_Power_of_all 	one_harfSubharmonics_Power_of_all 	superSubharmonics_of_all 	one_3rdSubharmonics_of_all 	one_harfSubharmonics_of_all 	finalhfno6000 	finalhnrd 	finalH1H2 	cpps 	jitterLocal 	shimmerLocal 	shimmerLocaldB 	psd 	gneMaximum 	slope 	tilt 	hnr

############################################################
############################################################
#Concatenate sv+cs to simple
for sub from 1 to number_of_patients
#■Select CS Sample
select left_Sound_No. + (sub-1)
name$ = selected$ ("Sound")
namecs$ = left$(name$, 16)


#■Select SV Sample
select  right_Sound_No.  + (sub-1)
name$ = selected$ ("Sound")
namesv$ = left$(name$, 16)


#■Confirmation that CS and SV samples are from the same patient
if  namesv$ <> namecs$
 appendInfoLine: namesv$
 appendInfoLine: namecs$
 appendInfoLine: "different patients of cs/sv sample!!!!!"
 STOP!!!!!!!!!
endif

select left_Sound_No. + (sub-1)
plus right_Sound_No.  + (sub-1)
Concatenate
Rename: "simpleCHAIN"



############################################################
############################################################


Font size... 8
selectObject: "Sound simpleCHAIN"
sounddefo = selected("Sound")
namedefo$ = selected$("Sound")

duration = Get total duration
x = frame_length
n = floor((duration-frame_length)/time_step)+2




#################################################################
#################################################################
###############↓↓↓↓ fo estimation by SFEEDS↓↓↓↓ ######################
#################################################################
#################################################################

#######Unify the average INTENSITY of the sample with avg_int########################
#Default is to resample Intensity
if intensity_resample = 1
Scale intensity: avg_int
endif


#######Calculate the mean fo of the sample####################
# Create a long-term average spectrum.
To Spectrum... yes
To Ltas (1-to-1)

#Find the spectral maximum peak for the entire sample (to be used as a comparison during silence evaluation).
sample_all_dB = Get maximum... 0 0 none

selectObject: "Spectrum 'namedefo$'"
plusObject: "Ltas 'namedefo$'"
Remove


#################################################################
#################### Beginning of overall delineation (0-1000Hz)　######################
#################################################################
Erase all

selectObject: sounddefo
To Pitch (ac): 0, 75, 15, "no", 0.03, 0.45, 0.01, 0.35, 0.14, 600
Rename... 'namedefo$'_1



#Spectrograms up to 1000 Hz are drawn.  
do ("Select outer viewport...", 0, 12, 0.2, 8)
select Sound 'namedefo$'
    To Spectrogram... 0.1 1000 0.002 2 Gaussian
　　    Black
      Paint... 0 0 0 0 100 yes 50 0 0 yes
    #Text: duration/2, "centre", 1020, "half", "'namecs$'"
　   Text: 0, "right", 100, "half", "100"
　　Red
    Text: duration*3/4, "centre", -20, "half", "fo is estimated by SFEEDS"

    ######################Drawing spectrograms and enclosures###############################
do ("Select outer viewport...", 0, 12, 0.2, 8)
    Black
    Line width... 0.5
   　select Pitch 'namedefo$'_1
     Formula: "0"
   　Draw... 0 0 0 1000 no


#################################################################
################ End of overall delineation.　###################
#################################################################



#################################################################
#########Start of frame-by-frame calculation and delineation.　　############
#################################################################


#######　Create files for frame analysis (Gaussian window ). ###############
##### x is the frame length #####
####  n is the number of frames ########
##### x*n = number of seconds available for analysis ##########


for number from 1 to 'n'
　　selectObject: sounddefo
   Extract part: (number-1)*'time_step', x+(number-1)*'time_step', "Gaussian1", 1, "no"
   Rename: "'namedefo$'_'number'"
endfor

############Start of frame-by-frame circulation.#################
#################################################################

for i from 1 to 'n'
selectObject: "Sound 'namedefo$'_'i'"

sound = selected("Sound")
name$ = selected$ ("Sound")

To Ltas: 6

#Find the maximum spectral peak in the frame.
frame_all_dB = Get maximum... 0 0 none


h_defo_dB = Get maximum... 50 400 none
h_defo_Hz = Get frequency of maximum... 50 400 none


for z from 2 to 7
h_'z'_dB = Get maximum... (z-1)/8*h_defo_Hz z/8*h_defo_Hz None
h_'z'_Hz = Get frequency of maximum... (z-1)/8*h_defo_Hz z/8*h_defo_Hz None
endfor

#################################################################
################### Dominant Spectrum Test　######################
#################################################################

#Select the fundamental frequency from these spectral peaks
#If the difference between the highest spectral peak and the highest spectral peak is within d(dB), the structure is recognised as an harmonics structure.
#In order from the lowest frequency.
#Adopt larger peaks in adjacent search ranges

if h_2_dB > h_defo_dB - d  and   h_2_dB > h_3_dB
  h1_Hz = h_2_Hz
  h1_dB = h_2_dB
elsif h_2_dB > h_defo_dB - d  and   h_2_dB < h_3_dB
  h1_Hz = h_3_Hz
  h1_dB = h_3_dB

elsif h_3_dB > h_defo_dB - d  and   h_3_dB > h_4_dB
  h1_Hz = h_3_Hz
  h1_dB = h_3_dB
elsif h_3_dB > h_defo_dB - d  and   h_3_dB < h_4_dB
  h1_Hz = h_4_Hz
  h1_dB = h_4_dB

elsif h_4_dB > h_defo_dB - d  and   h_4_dB > h_5_dB
  h1_Hz = h_4_Hz
  h1_dB = h_4_dB
elsif h_4_dB > h_defo_dB - d  and   h_4_dB < h_5_dB
  h1_Hz = h_5_Hz
  h1_dB = h_5_dB

elsif h_5_dB > h_defo_dB - d   and   h_5_dB > h_6_dB
  h1_Hz = h_5_Hz
  h1_dB = h_5_dB
elsif h_5_dB > h_defo_dB - d   and   h_5_dB < h_6_dB
  h1_Hz = h_6_Hz
  h1_dB = h_6_dB

elsif h_6_dB > h_defo_dB - d  and   h_6_dB > h_7_dB
  h1_Hz = h_6_Hz
  h1_dB = h_6_dB
elsif h_6_dB > h_defo_dB - d  and   h_6_dB < h_7_dB
  h1_Hz = h_7_Hz
  h1_dB = h_7_dB
 
elsif h_7_dB > h_defo_dB - d and h_7_dB > h_defo_dB
  h1_Hz = h_7_Hz
  h1_dB = h_7_dB

else
   h1_Hz = h_defo_Hz
   h1_dB = h_defo_dB
endif

  h1_score_'i' = h1_dB
  h1_Hz_'i' = h1_Hz

#################################################################
#################################################################
################ Sequential Spectrum Test　######################
#################################################################
#################################################################

#In the frequency band 1/10 around the frequency calculated in the previous frame (h1_Hz_'previous').
#If a frequency component with equivalent power (within ±1/10) and within ◯dB (noHarmonics_lower_than_frame) of the maximum spectrum in the frame is also present in this frame.
#The result of the Sequential Spectrum test is used as the frame frequency candidate in preference to the Dominant Spectrum test.
#In other words, when a continuous fo spectral structure cannot be confirmed between consecutive frames, such as at the start and end of a phrase or during a Pitch Jump, a new fo is detected by the Dominant Spectrum Test.

h1_Hz_0 = 0
h1_score_0 = 0
previous = i-1
previous2 = i-2
#appendInfoLine: previous
#appendInfoLine: h1_Hz_'previous'


######
if h1_Hz_'previous'<>0 
h_CompareWithPrevious_dB = Get maximum... 9/10*h1_Hz_'previous' 11/10*h1_Hz_'previous' None
h_CompareWithPrevious_Hz = Get frequency of maximum... 9/10*h1_Hz_'previous' 11/10*h1_Hz_'previous' None
#appendInfoLine: "previous_was_not0Hz"

if h_CompareWithPrevious_dB > h1_score_'previous' - dd and h_CompareWithPrevious_dB < h1_score_'previous' + dd and h_CompareWithPrevious_dB > frame_all_dB - noHarmonics_lower_than_frame 
  h1_score_'i' = h_CompareWithPrevious_dB
  h1_Hz_'i' = h_CompareWithPrevious_Hz

else
 #
endif

else
 #
endif




#################################################################
#################################################################
############# Dominant Spectrum Test　Completed ##################
############# Sequential Spectrum Test　Completed ################
#################################################################
#################################################################




################Search above and below the candidate frequency (h1_Hz_'i') in the frame####################
########################Correction if 2fo is mis-detected.####################################
###
# 1.5 times Hz of the extracted frequency
h_search15_dB_'i' = Get maximum... 1.5*h1_Hz_'i'-10 1.5*h1_Hz_'i'+10 None
h_search15_Hz_'i' = Get frequency of maximum... 1.5*h1_Hz_'i'-10 1.5*h1_Hz_'i'+10 None

# 0.5 times Hz of the extracted frequency
h_search05_dB_'i' = Get maximum... 1/2*h1_Hz_'i'-10 1/2*h1_Hz_'i'+10 None
h_search05_Hz_'i' = Get frequency of maximum... 1/2*h1_Hz_'i'-10 1/2*h1_Hz_'i'+10 None


#If 2fo is mis-detected, the spectral intensity should be fo≒2fo.
#If the spectrum with the lower (0.5x) intra-frame candidate frequency (h1_Hz_'i') is within ddd(db) of the peak difference with h1_score_'i' and is strong enough to be a valid overtone compared to the whole frame dB, then 2fo is mis-detected.
if h_search05_dB_'i' > h1_score_'i' - ddd and h_search05_dB_'i' > frame_all_dB - noHarmonics_lower_than_frame
  h1_score_'i' =   h_search05_dB_'i'
  h1_Hz_'i' =  h_search05_Hz_'i' 
endif


########################Correction if 1.5fo is mis-detected####################################
# 2/3 times Hz of the extracted frequency
h_search23_dB_'i' = Get maximum... 2/3*h1_Hz_'i'-10 2/3*h1_Hz_'i'+10 None
h_search23_Hz_'i' = Get frequency of maximum... 2/3*h1_Hz_'i'-10 2/3*h1_Hz_'i'+10 None

# If h_search23_dB is within ddd(db) of the peak difference from h1_score_'i' and is strong enough to be a valid overtone compared to the whole frame dB, 1.5 fo is corrected as mis-detected.
if  h_search23_dB_'i' > h1_score_'i' - ddd   and  h_search23_dB_'i' > frame_all_dB - noHarmonics_lower_than_frame
  h1_score_'i' =   h_search23_dB_'i'
  h1_Hz_'i' =  h_search23_Hz_'i' 
endif




###############################################################


#▲Frames that are lower than the maximum dB of the entire sample by more than ◯dB (noLoud_lower_than_allsample) are set to 0 dB as "silent".
if  h1_score_'i' < sample_all_dB - noLoud_lower_than_allsample
  h1_score_'i' = 0
  h1_Hz_'i' = 0
endif

#Excludes recording noise and the low-frequency spectrum generated by speech tremor.
if h1_Hz_'i' <50
   h1_score_'i' = 0
  　h1_Hz_'i' = 0
endif


#################################################################
if draw_Results = 1

#Drawing extracted fo for each frame.
#The spectrum set to 0 above as too weak is not drawn in the Spectrogram.
if  h1_score_'i' > 0
do ("Select outer viewport...", 0, 12, 0.2, 8)
    Red
    Paint circle (mm): "red", time_step*(i-1)+frame_length/2, h1_Hz_'i', 0.6
endif

endif


#################################################################
#################################################################

#Remove unwanted files generated by frame analysis.
selectObject: "Ltas 'name$'"
Remove


 bin_f0PeakdB_'i' = h1_score_'i' 
 bin_f0PeakHz_'i' = h1_Hz_'i'

endfor


#################################################################
############ End of frame-by-frame delineation.　################
#################################################################





select Pitch 'namedefo$'_1
plus Spectrogram 'namedefo$'
Remove



#################################################################
#################################################################
###############↑↑↑↑ fo estimation by SFEEDS↑↑↑↑ ######################
#################################################################
#################################################################

#pause  stop
#goto testSFEEDS

#################################################################
#################################################################
######Assign h1_score_'i' and h1_Hz_'i' to all frames　   #######
#################################################################
#################################################################

#for i from 1 to 'n'
#appendInfoLine: "",h1_Hz_'i'," 　　　",h1_score_'i'," "
#endfor


#################################################################
#################################################################
#################################################################
#################################################################
#################################################################
#################################################################
###########↓↓↓↓ Subharmonics Quantification↓↓↓↓ #################
#################################################################
#################################################################
#################################################################
#################################################################
#################################################################
#################################################################

# If time_step = 0.0033sec, search subharmonics at intervals of d times (e.g., 0.0033*40 = 0.123sec for 40 times)

#If all frames (n) are equally divided by (div), the calculation is limited to (divcount) frames only
divd = 20
divcount = floor(n/divd)

#Subharmonics search window is drawn in black on the spectrogram. 
#Note that here, a new frame number ii is assigned for the subharmonics search.
#Note here that the ii th frame corresponds to the ii*d th frame of the original!
if draw_subh_search_frame = 1
for ii from 1 to 'divcount'
do ("Select outer viewport...", 0, 12, 0.2, 8)
    Black
    Paint rectangle: 0.1, time_step*(divd*ii-1), time_step*(divd*ii-1)+frame_length, 0, 10   
#　　　　　　　　　Text: time_step*(divd*ii-1)+frame_length/2, "centre", -10, "half", "'ii'"
endfor
endif


#################################################################
#################################################################
#########↓↓↓↓Search at ii*divdth (= ssth) frame↓↓↓↓ ###############
#################################################################
#################################################################

#Subharmonics original frame number (ss-th) from which the extract is taken.
#for ii from 1 to 'divcount'
#ss = ii*divd
#  appendInfoLine: ii*40
#  appendInfoLine: h1_db_'ss'
#endfor



#################################################################
##### Leave only equally spaced frames sorted for Subharmonics testing　#######
#################################################################


for ii from 1 to 'divcount'
ss = ii*divd
　#Subharmonics original frame number (ssth) extracted at equal intervals (divd skipped).

selectObject: "Sound 'namedefo$'_'ss'"
　#Lats (bins every 6Hz) created for every frame
　#0.1sec frame does not allow for more detailed spectral frequency analysis
To Ltas: 6
　#Assign a serial number (ii=1~divcountth) to SubhSearchFrame
　#The iith SubhSearchFrame corresponds to the original frame ss(ii*40)th.
Rename: "'namedefo$'_SubhSearchFrame_'ii'"
endfor



##Delete all original frames, leaving only the Ltas of SubhSearchFrame
selectObject: "Sound 'namedefo$'_1"
for number from 2 to 'n'
plusObject: "Sound 'namedefo$'_'number'"
endfor
Remove


#################################################################
#################################################################
#################################################################
#################################################################
##### Subharmonics search starts for each SubhSearchFrame.　#####
###Sequential numbers (ii=1~divcountth) are assigned to SubhSearchFrame.　###
###The ii-th SubhSearchFrame corresponds to the original frame ss(ii*40)th###
#################################################################
#################################################################
#################################################################
#################################################################


for ii from 1 to 'divcount'
ss = ii*divd

selectObject: "Ltas 'namedefo$'_SubhSearchFrame_'ii'"



#SubhSearchFrameをそれぞれ、下記Subhに分類
 #subhType_'ii' = 0 :　Default state, adapted in the silent part
 #subhType_'ii' = 1 :　Default state, adapted in the silent part
 #subhType_'ii' = 2 :　Frame in which 1/2Subharmonics exists 　　(3)Test order
 #subhType_'ii' = 3 :　Frames with 1/3~1/4Subharmonic　　　　　　 (2) Test order
 #subhType_'ii' = 4 :  Frames with more than one SuperSubharmonics   (1) Test order

subhType_'ii' = 0




#These variables are reset once before and set to 0 when circulation begins
 h1NOISEh2 = 0
 bin_BIPHOPeakdB = 0
 bin_BIPHOPeakHz = 0
 bin_SUBH3PeakdB = 0
 bin_SUBH3PeakHz = 0
 bin_SUBH2PeakdB = 0
 bin_SUBH2PeakHz = 0

 h1NOISEh2_rltv = 0
 bin_BIPHOrltvdB = 0
 bin_SUBH3rltvdB = 0
 bin_SUBH2rltvdB = 0


#If h1_score_'ss' > 0, then it is a silent part without Harmonics and no search is performed
if　 h1_score_'ss' = 0
goto noHARMONICS
endif



#################################################################
############ For calculation of h1NOISEh2__rltv　################
#################################################################

#Average noise in the middle 1/2
　h1NOISEh2 = Get mean: 5/4*h1_Hz_'ss', 7/4*h1_Hz_'ss', "energy" 
　h1NOISEh2_rltv  = h1_score_'ss' - h1NOISEh2
endif


#Only noise greater than 10 dB counted as audible
#if  h1NOISEh2_'i' > 10
#   h1NOISEh2_above10_'i' = h1NOISEh2_'i' - 10
#else 
#   h1NOISEh2_above10_'i' = 0
#endif


#################################################################
############ For examination by SUBHARMONICS Type　############## 
#################################################################



##############. Investigate one bin at a time from fo to 2fo　##################### 

#bin_f0 indicates the bin number where fo exists
bin_f0 = (h1_Hz_'ss'/6)+0.5
#appendInfoLine: bin_f0


for b from bin_f0 to 2*bin_f0
  bin_nexttof0_'b' = Get value in bin...  b
　#appendInfoLine: bin_nexttof0_'b'
endfor




#If the detected f0 is too small to calculate the low frequency bin, only the result of h1NOISEh2 is reflectedる
#f0 < approx. 11.5 bin = approx. 70 Hz
if bin_f0 > floor(23/16*bin_f0)-5
  goto tooLowfo
endif
 



#①
#BIPHONATION (BIPHO)
#Tests SuperSubharmonics with peaks in the range from f0 to less than 5/4f0
#Search until 4 bins of (b-3)~b form a peak (peak is b-2) above the biphonationPeakdBthreshold (default is 5) dB
#Requirement that b2-b3 or b2-b4 or b2-b5 be greater
#Furthermore, if the peak of the mountain is within 20 dB of the dB of f0 and the difference value, BIPHONATION
for b from bin_f0+5 to round(5/4*bin_f0)+2
#where b is the beginning of the 5-sequence bin to be searched
b5 = b-5
b4 = b-4
b3 = b-3
b2 = b-2
b1 = b-1
b0 = b
if bin_nexttof0_'b3' < bin_nexttof0_'b2' and bin_nexttof0_'b2' > bin_nexttof0_'b1' and bin_nexttof0_'b1' > bin_nexttof0_'b0' and  (bin_nexttof0_'b2'-bin_nexttof0_'b5' >biphonationPeakdBthreshold or bin_nexttof0_'b2'-bin_nexttof0_'b4' >biphonationPeakdBthreshold or bin_nexttof0_'b2'-bin_nexttof0_'b3' >biphonationPeakdBthreshold and bin_nexttof0_'b2'-bin_nexttof0_'b0'>biphonationPeakdBthreshold) and bin_nexttof0_'b2' > h1_score_'ss' - 20
 bin_BIPHOPeakNo = b-2 
 bin_BIPHOPeakdB = Get value in bin...  bin_BIPHOPeakNo
 bin_BIPHOPeakHz = (bin_BIPHOPeakNo-0.5)*6 
 bin_BIPHOrltvdB = h1_score_'ss' - bin_BIPHOPeakdB
 subhType_'ii' = 4
 goto biphonationDetected
endif
endfor


#②
#1/4or1/3 SUBHARMONIC
#Subharmonics with peaks in the range 5/4f0 to 23/16f0 (total 3/16) are tested
#Search until 7 bins of (bb-6)~bb form a peak (peak is bb-3) above subharmonic3PeakdBthreshold (default is 5) dB
#Furthermore, if the peak of the mountain is within 25 dB of the dB of f0 and the difference value, then 1/3Subharmonics
for bb from floor(5/4*bin_f0)+3 to round(23/16*bin_f0)+2
bb6 = bb-6
bb5 = bb-5
bb4 = bb-4
bb3 = bb-3
bb2 = bb-2
bb1 = bb-1
bb0 = bb

if bin_nexttof0_'bb5' < bin_nexttof0_'bb4' and bin_nexttof0_'bb4' < bin_nexttof0_'bb3' and bin_nexttof0_'bb3' > bin_nexttof0_'bb2' and bin_nexttof0_'bb2' > bin_nexttof0_'bb1' and bin_nexttof0_'bb1' > bin_nexttof0_'bb0' and  (bin_nexttof0_'bb3'-bin_nexttof0_'bb6' >subharmonic3PeakdBthreshold or bin_nexttof0_'bb3'-bin_nexttof0_'bb5' >subharmonic3PeakdBthreshold and bin_nexttof0_'bb3'-bin_nexttof0_'bb0'>subharmonic3PeakdBthreshold) and bin_nexttof0_'bb3' > h1_score_'ss' - 25
 bin_SUBH3PeakNo = bb-3 
 bin_SUBH3PeakdB = Get value in bin...  bin_SUBH3PeakNo
 bin_SUBH3PeakHz = (bin_SUBH3PeakNo-0.5)*6 
 bin_SUBH3rltvdB = h1_score_'ss' - bin_SUBH3PeakdB
 subhType_'ii' = 3
 goto subharmonic3Detected
endif
endfor




#③
#1/2SUBHARMONIC
#Test for subharmonics with peaks in the range 23/16f0 to 25/16f0 (middle 1/8 of f0 and 2f0)
#Search until 7 bins of (bbb-6)~bbb form a peak (peak is bbb-3) above subharmonic2PeakdBthreshold (default is 5) dB
#Furthermore, if the peak of the mountain is within 25 dB of the dB of f0 and the difference value, then 1/2Subharmonics
for bbb from round(23/16*bin_f0)+2 to round(25/16*bin_f0)+3
bbb6 = bbb-6
bbb5 = bbb-5
bbb4 = bbb-4
bbb3 = bbb-3
bbb2 = bbb-2
bbb1 = bbb-1
bbb0 = bbb

h2_NarrowMax = Get maximum... (16*2-1)/16*h1_Hz_'ss' (16*2+1)/16*h1_Hz_'ss' none
searchFORsubh2mindB = Get minimum... 26/16*h1_Hz_'ss' 7/4*h1_Hz_'ss' none
searchFORsubh2thresholddB = (h1_score_'ss' + h2_NarrowMax)/2

if bin_nexttof0_'bbb6' < bin_nexttof0_'bbb5' and bin_nexttof0_'bbb5' < bin_nexttof0_'bbb4' and bin_nexttof0_'bbb4' < bin_nexttof0_'bbb3' and bin_nexttof0_'bbb3' > bin_nexttof0_'bbb2' and bin_nexttof0_'bbb2' > bin_nexttof0_'bbb1' and bin_nexttof0_'bbb1' > bin_nexttof0_'bbb0' and  (bin_nexttof0_'bbb3'-bin_nexttof0_'bbb6' >subharmonic2PeakdBthreshold or bin_nexttof0_'bbb3'-bin_nexttof0_'bbb0'>subharmonic2PeakdBthreshold) and bin_nexttof0_'bbb3' > h1_score_'ss' - 25  
#if bin_nexttof0_'bbb6' < bin_nexttof0_'bbb5' and bin_nexttof0_'bbb5' < bin_nexttof0_'bbb4' and bin_nexttof0_'bbb4' < bin_nexttof0_'bbb3' and bin_nexttof0_'bbb3' > bin_nexttof0_'bbb2' and bin_nexttof0_'bbb2' > bin_nexttof0_'bbb1' and bin_nexttof0_'bbb1' > bin_nexttof0_'bbb0' and  (bin_nexttof0_'bbb3'-bin_nexttof0_'bbb6' >subharmonic2PeakdBthreshold or bin_nexttof0_'bbb3'-bin_nexttof0_'bbb0'>subharmonic2PeakdBthreshold) and bin_nexttof0_'bbb3' > h1_score_'ss'/4   and bin_SUBH2PeakdB - searchFORsubh2mindB > 10 and searchFORsubh2thresholddB - bin_SUBH2PeakdB < 30

 bin_SUBH2PeakNo = bbb-3 
 bin_SUBH2PeakdB = Get value in bin...  bin_SUBH2PeakNo
 bin_SUBH2PeakHz = (bin_SUBH2PeakNo-0.5)*6 
 bin_SUBH2rltvdB = h1_score_'ss' - bin_SUBH2PeakdB
 subhType_'ii' = 2
 goto subharmonic2Detected
endif
endfor


#④
#Only if all of the Super, 1/3, and 1/2 Subharmonics are not present, or if f0 is too small to calculate the low frequency bin
#Frames containing Harmonics arrive here
label tooLowfo
subhType_'ii' = 1



##########　SubharmonicsSearchFrame毎のSubharmonics検定後のジャンプ先
label noHARMONICS
label biphonationDetected
label subharmonic3Detected
label subharmonic2Detected


#SubharmonicsSearchFrame ii.
#SubharmonicsType is assigned a value by SubharmonicsType.
 h1NOISEh2_'ii' =  h1NOISEh2
 bin_BIPHOPeakdB_'ii'　= bin_BIPHOPeakdB
 bin_BIPHOPeakHz_'ii' =  bin_BIPHOPeakHz
 bin_SUBH3PeakdB_'ii' =  bin_SUBH3PeakdB
 bin_SUBH3PeakHz_'ii' =  bin_SUBH3PeakHz
 bin_SUBH2PeakdB_'ii' =  bin_SUBH2PeakdB
 bin_SUBH2PeakHz_'ii' =  bin_SUBH2PeakHz

 h1NOISEh2_rltv_'ii'  =  h1NOISEh2_rltv
 bin_BIPHOrltvdB_'ii' =  bin_BIPHOrltvdB 
 bin_SUBH3rltvdB_'ii' =  bin_SUBH3rltvdB
 bin_SUBH2rltvdB_'ii' =  bin_SUBH2rltvdB


endfor
#The for syntax for each SubharmonicsSearchFrame is closed here.




############### Detects cases where the SubharmonicsSearchFrame result matches two consecutive frames　##################
 #If two adjacent SubhSearchFrames are classified as the same Subh, they are determined as the same Subh.
 #subhTypeFin_'ii' = 0 :　 Default state 
 #subhTypeFin_'ii' = 1 :　Frames with ChaoticNoise (Harmonics frames without Subharmonics below)
 #subhTypeFin_'ii' = 2 :　Frame with 1/2Subharmonics present　　　　　　 
 #subhTypeFin_'ii' = 3 :　Frames with 1/3~1/4Subharmonic present　　 
 #subhTypeFin_'ii' = 4 :  Frames with more SuperSubharmonics than that  

#Once all frames are set to default
for ii from 1 to 'divcount'
 subhTypeFin_'ii' = 0  
endfor



for ii from 1 to 'divcount'-1
iii = ii+1
 if subhType_'ii' = subhType_'iii'　and (  abs(bin_BIPHOPeakHz_'ii'- bin_BIPHOPeakHz_'iii')<15  and  abs(bin_SUBH3PeakHz_'ii'- bin_SUBH3PeakHz_'iii')<15  and abs( bin_SUBH2PeakHz_'ii'-  bin_SUBH2PeakHz_'iii')<15 )
  subhTypeFin_'ii' = subhType_'ii'
  subhTypeFin_'iii' = subhType_'iii'
 elsif  subhType_'iii' = 1 or subhType_'iii' = 2 or subhType_'iii' = 3
   subhTypeFin_'iii' = 1
 endif
endfor



###############Subharmonics rendering in Spectrogram##################
for ii from 1 to 'divcount'
ss = ii*divd

if subhTypeFin_'ii' = 4
 Purple
    Line width... 3
    Draw line: time_step*(ss-1), bin_BIPHOPeakHz_'ii', time_step*(ss-1)+frame_length, bin_BIPHOPeakHz_'ii'
endif

if subhTypeFin_'ii' = 3
 Green
    Line width... 3
    Draw line: time_step*(ss-1), bin_SUBH3PeakHz_'ii', time_step*(ss-1)+frame_length, bin_SUBH3PeakHz_'ii'
endif

if subhTypeFin_'ii' = 2
 Cyan
    Line width... 3
    Draw line: time_step*(ss-1), bin_SUBH2PeakHz_'ii', time_step*(ss-1)+frame_length, bin_SUBH2PeakHz_'ii'
endif

if subhTypeFin_'ii' = 1
 Pink
    Line width... 3
    Draw line: time_step*(ss-1), 20, time_step*(ss-1)+frame_length, 20
endif


endfor


#################################################################
########## End of search for each SubharmonicsSearchFrame　##################
#################################################################




############################################################
############################################################
######## SubharmonicsSearchFrame frame analysis produced by SubharmonicsSearchFrame removes unwanted files. #######
############################################################
############################################################

selectObject: "Ltas 'namedefo$'_SubhSearchFrame_1"
for ii from 2 to 'divcount'
plusObject: "Ltas 'namedefo$'_SubhSearchFrame_'ii'"
endfor
Remove







#################################################################
#################################################################
#################################################################
#############↓↓↓↓ Subharmonics quantification↓↓↓↓ ###############
#################################################################
#################################################################
#################################################################



###########↓↓↓↓ Number and percentage of frames for which fo was detected in SubharmonicsSearchFrame　　↓↓↓↓ ############
#############################【frameHarmonics_SUM】#################################
##############################【percent_Harmonics】#################################

for ii from 1 to 'divcount'
ss = ii*divd
 if h1_score_'ss' = 0
   frameHarmonics_'ii' = 0
 else
   frameHarmonics_'ii' = 1
 endif
endfor

# Initialize variable (frameHarmonics_SUM) to store totals
frameHarmonics_SUM = 0
for ii from 1 to 'divcount'
   frameHarmonics_SUM += frameHarmonics_'ii'
endfor

# Output results
#appendInfoLine: "Total Harmonics: ", frameHarmonics_SUM
#appendInfoLine: "Total SubharmonicsSearchFrame: ", divcount

#Percentage of frames in the total sample that are accounted for by Harmonics (approximate)
percent_Harmonics = frameHarmonics_SUM/divcount*100
#appendInfoLine: "Total SubharmonicsSearchFrame(%): ", percent_Harmonics



###########################【frameChaoticNoise_SUM】#############################
###########################【percent_ChaoticNoise】#############################
########################【chaoticNoise_Power_of_all】#############################

for ii from 1 to 'divcount'
ss = ii*divd
 if subhTypeFin_'ii' = 1
   frameChaoticNoise_'ii' = 1
 else
   frameChaoticNoise_'ii' = 0
 endif
endfor

# Initialize variable (frameChaoticNoise_SUM) to store the total
frameChaoticNoise_SUM = 0
for ii from 1 to 'divcount'
   frameChaoticNoise_SUM += frameChaoticNoise_'ii'
endfor

# Output results
#appendInfoLine: "Total ChaoticNoise: ", frameChaoticNoise_SUM

#Percentage of frames in the entire sample that are ChaoticNoise (approximate)
percent_ChaoticNoise = frameChaoticNoise_SUM/divcount*100
#appendInfoLine: "Total SubharmonicsSearchFrame(%): ", percent_ChaoticNoise

#Relative ChaoticNoise power (dB) per frame (compared to f0)
#Initialize variable (frameChaoticNoise_Power_SUM) to store the total
frameChaoticNoise_Power_SUM = 0
for ii from 1 to 'divcount'
   frameChaoticNoise_Power_SUM += h1NOISEh2_rltv_'ii'
endfor

chaoticNoise_Power_per_frame = frameChaoticNoise_Power_SUM / frameChaoticNoise_SUM
chaoticNoise_Power_of_all = frameChaoticNoise_Power_SUM / frameHarmonics_SUM
#appendInfoLine: "ChaoticNoise_Power_per_frame(dB): ", chaoticNoise_Power_per_frame
#appendInfoLine: "ChaoticNoise_Power_of_all(dB): ", chaoticNoise_Power_of_all


###########################【frameSuperSubharmonics_SUM】#############################
########################【superSubharmonics_of_all】#############################
#####################【superSubharmonics_Power_of_all】#############################

for ii from 1 to 'divcount'
ss = ii*divd
 if subhTypeFin_'ii' = 4
   frameSuperSubharmonics_'ii' = 1
 else
   frameSuperSubharmonics_'ii' = 0
   bin_BIPHOrltvdB_'ii'  = 0
   bin_BIPHOPeakdB_'ii'  = 0
 endif
endfor

#Initialize variable (frameSuperSubharmonics_SUM) to store totals
frameSuperSubharmonics_SUM = 0
for ii from 1 to 'divcount'
   frameSuperSubharmonics_SUM += frameSuperSubharmonics_'ii'
endfor

#SuperSubharmonicsdB) relative to f0 per frame
#Initialize variable (superSubharmonics_Power_SUM) to store totals
superSubharmonics_Power_SUM = 0
for ii from 1 to 'divcount'
   superSubharmonics_Power_SUM += bin_BIPHOrltvdB_'ii'
endfor

 superSubharmonics_Power_of_all = superSubharmonics_Power_SUM / frameHarmonics_SUM



#Output results
#appendInfoLine: "Total SuperSubharmonics: ", frameSuperSubharmonics_SUM

superSubharmonics_of_all = frameSuperSubharmonics_SUM / frameHarmonics_SUM *100
#Output results
#appendInfoLine: "mean SuperSubharmonics(%): ", superSubharmonics_of_all



###########################【frame1_3rdSubharmonics_SUM】#############################
########################【one_3rdSubharmonics_of_all】#############################
####################【one_3rdSubharmonics_Power_of_all】#############################
for ii from 1 to 'divcount'
ss = ii*divd
 if subhTypeFin_'ii' = 3
   frame1_3rdSubharmonics_'ii' = 1
 else
   frame1_3rdSubharmonics_'ii' = 0
    bin_SUBH3PeakdB_'ii'  = 0
    bin_SUBH3rltvdB_'ii'  = 0
 endif
endfor

# Initialize variable (frame1_3rdSubharmonics_SUM) to store totals
frame1_3rdSubharmonics_SUM = 0
for ii from 1 to 'divcount'
   frame1_3rdSubharmonics_SUM += frame1_3rdSubharmonics_'ii'
endfor


#Relative value of one_3rdSubharmonicsdB) per frame (compared to f0)
#Initialize variable (one_3rdSubharmonics_Power_SUM) to store totals
one_3rdSubharmonics_Power_SUM = 0
for ii from 1 to 'divcount'
   one_3rdSubharmonics_Power_SUM += bin_SUBH3rltvdB_'ii'
endfor

 one_3rdSubharmonics_Power_of_all = one_3rdSubharmonics_Power_SUM / frameHarmonics_SUM



# Output results
#appendInfoLine: "Total 1/3Subharmonics: ", frame1_3rdSubharmonics_SUM

one_3rdSubharmonics_of_all = frame1_3rdSubharmonics_SUM / frameHarmonics_SUM *100
# Output results
#appendInfoLine: "mean 1/3Subharmonics(%): ", one_3rdSubharmonics_of_all


###########################【frame1_harfSubharmonics_SUM】#############################
########################【one_harfSubharmonics_of_all】#############################
#####################【 one_harfSubharmonics_Power_of_all】#############################
for ii from 1 to 'divcount'
ss = ii*divd
 if subhTypeFin_'ii' = 2
   frame1_harfSubharmonics_'ii' = 1
 else
   frame1_harfSubharmonics_'ii' = 0
   bin_SUBH2PeakdB_'ii'  = 0
   bin_SUBH2rltvdB_'ii'  = 0
 endif
endfor

# Initialize variable (frame1_harfSubharmonics_SUM) to store the total
frame1_harfSubharmonics_SUM = 0
for ii from 1 to 'divcount'
   frame1_harfSubharmonics_SUM += frame1_harfSubharmonics_'ii'
endfor


#Relative value of one_harfSubharmonicsdB) per frame (compared to f0)
# Initialize variable (one_harfSubharmonics_Power_SUM) to store totals
one_harfSubharmonics_Power_SUM = 0
for ii from 1 to 'divcount'
   one_harfSubharmonics_Power_SUM += bin_SUBH2rltvdB_'ii'
endfor

 one_harfSubharmonics_Power_of_all = one_harfSubharmonics_Power_SUM / frameHarmonics_SUM



# Output results
#appendInfoLine: "Total 1/2Subharmonics: ", frame1_harfSubharmonics_SUM

one_harfSubharmonics_of_all = frame1_harfSubharmonics_SUM / frameHarmonics_SUM *100
# Output results
#appendInfoLine: "mean 1/2Subharmonics(%): ", one_harfSubharmonics_of_all




#################################################################
############## Start drawing calculation results to Innner Viewport　#################
#################################################################
# Perform initial setup
Solid line
Line width... 1
Black
Helvetica

# Set viewport to display title and researcher information
Font size... 5
Select inner viewport... 0 12 0 0.2
Axes... 0 12 0 10
Text... 1 Left 0 Half Script: Itsuki Kitayama and Kiyohito Hosokawa

# Show title
Font size... 12
Select inner viewport... 0 12 0 0.3
Axes... 0 12 0 10
Text... 1 Left 0 Half ##ACOUSTIC ROUGHNESS INDEX (ARI)#

# The part displaying patient information (commented out)
Font size... 12
Select inner viewport... 0 12 0 0.3
Axes... 0 12 0 10
Text... 11 Right 0 Half ##'namecs$'#

# Oscillogram
Select inner viewport... 0.7 11.3 8 9
selectObject: "Sound simpleCHAIN"
Draw... 0 0 0 0 no Curve
Draw inner box


selectObject: "Sound simpleCHAIN"
Remove



#########################################################################
################　Calculation of other acoustic indices　##########################
#########################################################################
#########################################################################

#goto without_others


# --------------------------------------------------------------------------------------------
# PART 0:
# HIGH-PASS FILTERING OF THE SOUND FILES. 
#CRemove spectrum (fluctuation and other elements) below 34 Hz in S-files
# --------------------------------------------------------------------------------------------

#■Select CS Sample
select left_Sound_No. + (sub-1)
Filter (stop Hann band)... 0 34 0.1
Rename... cs2


#■Select SV Sample
select  right_Sound_No.  + (sub-1)
name$ = selected$ ("Sound")
namesv$ = left$(name$, 16)
Copy... sv



# --------------------------------------------------------------------------------------------
# PART 1:
# DETECTION, EXTRACTION AND CONCATENATION OF
# THE VOICED SEGMENTS IN THE RECORDING
# OF CONTINUOUS SPEECH.
# Detect, extract, and combine voiced parts of CS samples
# --------------------------------------------------------------------------------------------
select Sound cs2
Copy... original
samplingRate = Get sampling frequency
intermediateSamples = Get sampling period
durationCS = Get total duration
# Create 0.001 second file with Inteinsity0
Create Sound... onlyVoice 0 0.001 'samplingRate' 0 
select Sound original
#　Text grid feature to isolate the overall maximum Intnsity -25dB or less as silence
To TextGrid (silences)... 50 0.003 -25 0.1 0.1 silence sounding
select Sound original
plus TextGrid original
Extract intervals where... 1 no "does not contain" silence
Concatenate
select Sound chain
# Creating ONLY Loud samples
Rename... onlyLoud
numberOfonlyLoud =selected ("Sound") ;Syntax for the removement of intermediate objects
#　Set the sound pressure power of OnlyLoud as globalPower.
globalPower = Get power in air
select TextGrid original
Remove

# Remove intermediate objects
selectObject: numberOfonlyLoud-1
nameOflastsilence$ = selected$ ("Sound")
numberOfsilence = number(mid$ (nameOflastsilence$, 18, length(nameOflastsilence$)))
for j from 1 to numberOfsilence
selectObject: "Sound original_silence_'j'"
Remove
endfor
# Remove intermediate objects



# Generate “voiced” samples------------------------------------------------------
# First, the Onlyloud sample is divided into 30 ms segments.
# Next, segments that satisfy all the conditions of 30% or more of the sound pressure power of OnlyLoud and a zero-crossing rate of 3000 Hz or less are targeted.
# ------------------------------------------------------
select Sound onlyLoud
# Sample length of Onlyloud
signalEnd = Get end time
windowBorderLeft = Get start time
#0Split into .03s segments
#Argument at the end of segment
windowWidth = 0.03
windowBorderRight = windowBorderLeft + windowWidth
#　Set the sound pressure power of OnlyLoud as globalPower.
globalPower = Get power in air

voicelessThreshold = globalPower*(30/100)

select Sound onlyLoud
# Defines the rightmost side of the analysis
extremeRight = signalEnd - windowWidth
# Split from 0 seconds to 0,03 seconds each.
while windowBorderRight < extremeRight
	Extract part... 'windowBorderLeft' 'windowBorderRight' Rectangular 1.0 no
	select Sound onlyLoud_part
	partialPower = Get power in air
#　When the sound pressure power of OnlyLoud is set as globalPower, the first condition of “voiced sound” is defined as when the sound pressure power is divided by 0.03s and other areas have a sound pressure power of 30% or more of that value.
	if partialPower > voicelessThreshold
　　　　# Call procedure
		call checkZeros 0
	   # When zeroCrossingRate < 3000, 0.03 seconds are added as a voiced interval
　　　　if (zeroCrossingRate <> undefined) and (zeroCrossingRate < 3000)
			select Sound onlyVoice
			plus Sound onlyLoud_part
			Concatenate
			Rename... onlyVoiceNew
			select Sound onlyVoice
			Remove
			select Sound onlyVoiceNew
			Rename... onlyVoice
		endif
	endif
	select Sound onlyLoud_part
	Remove
	windowBorderLeft = windowBorderLeft + 0.03
	windowBorderRight = windowBorderLeft + 0.03
	select Sound onlyLoud
endwhile
select Sound onlyVoice
durationCSvoiced = Get total duration


# procedure named checkZeros 
#　zeroCrossingRate as an argument.
procedure checkZeros zeroCrossingRate
	start = 0.0025
	startZero = Get nearest zero crossing... 'start'
	findStart = startZero
	findStartZeroPlusOne = startZero + intermediateSamples
	startZeroPlusOne = Get nearest zero crossing... 'findStartZeroPlusOne'
	zeroCrossings = 0
	strips = 0

	while (findStart < 0.0275) and (findStart <> undefined)
		while startZeroPlusOne = findStart
			findStartZeroPlusOne = findStartZeroPlusOne + intermediateSamples
			startZeroPlusOne = Get nearest zero crossing... 'findStartZeroPlusOne'
		endwhile
		afstand = startZeroPlusOne - startZero
		strips = strips +1
		zeroCrossings = zeroCrossings +1
		findStart = startZeroPlusOne
	endwhile
	zeroCrossingRate = zeroCrossings/afstand
endproc





# --------------------------------------------------------------------------------------------
# PART 2:
# DETERMINATION OF THE 6 ACOUSTIC MEASURES
# AND CALCULATION OF THE ACOUSTIC Breathiness INDEX.
# --------------------------------------------------------------------------------------------

# Middle of sv 3 sec extraction
select Sound sv
durationVowel = Get total duration
durationStart=durationVowel/2-1.5
durationEnd=durationVowel/2+1.5
if durationVowel>3
Extract part... durationStart durationEnd rectangular 1 no
Rename... sv2
elsif durationVowel<=3
Copy... sv2
endif

# Concatenated in order of cs and sv (time not unified)
select Sound onlyVoice
durationOnlyVoice = Get total duration
plus Sound sv2
Concatenate
Rename... ari
durationAll = Get total duration
minimumSPL = Get minimum... 0 0 None
maximumSPL = Get maximum... 0 0 None


# Analyses

start = do ("Get start time")
end = do ("Get end time")
duration = do ("Get total duration")
durationAnalysisWindow = 0.1
halfDurationAnalysisWindow = durationAnalysisWindow/2
numberOfWindows = floor (duration/durationAnalysisWindow)

# Analyses on portions with durationAnalysisWindow


	# Intermediate tables

do ("Create Table with column names...", "hfno", 0, "hfno6000")
do ("Create Table with column names...", "hnrd", 0, "hnrd")
do ("Create Table with column names...", "h1h2", 0, "h1h2")


######### Segmentation into portions of 0.05 s, and analyses on these portions
######### Calculate each element by dividing by 0.1 second


for n from 1 to numberOfWindows

	selectObject ("Sound ari")
	endWindow = start + (n*durationAnalysisWindow)
	startWindow = endWindow-durationAnalysisWindow
	do ("Extract part...", startWindow, endWindow, "rectangular", 1, "yes")
	do ("Rename...", "soundInWindow")
	

# High Frequency Noise (hfno) ############################################################


	do ("To Spectrum...", "yes")
	do ("To Ltas (1-to-1)")

	ltasMinimum = do ("Get minimum...", 0, 10000, "None")
	if ltasMinimum < 0
       #If the minimum spectrum is less than 0 dB, add its absolute value and bottom out the minimum to 0
		ltasMinimum = abs (ltasMinimum)
		do ("Formula...", "self+ltasMinimum")
	elsif ltasMinimum >= 0
       #If the minimum spectrum is greater than 0 dB, subtract that amount to reduce the minimum to 0
		do ("Formula...", "self-ltasMinimum")
	endif
	#Calculate spectral power averages (0-6000 and 6000-10000)
　　#Find its ratio (0-6000 power/6000-10,000 power)
　　ltasEnergy0to6kHz = do ("Get mean...", 0, 6000, "energy")
	ltasEnergy6to10kHz = do ("Get mean...", 6000, 10000, "energy")
	hfno6000 = ltasEnergy0to6kHz/ltasEnergy6to10kHz
selectObject ("Table hfno")
　　# Add row row (horizontal) in all columns columm (vertical)
	do ("Append row")
　　#Fill in the number, element name, and number on that line
	do ("Set numeric value...", n, "hfno6000", hfno6000)　
　　#　Calculate the average of columm up to that point.
	meanhfno6000 = do ("Get mean...", "hfno6000")



	
# HNR-Dejonckere (hnrd) (between 0.5-1.5 kHz) ############################################################

　　　   # (after f0 determination: (a) cepstrum, (b) LTAS) 

	selectObject ("Sound soundInWindow")
	startSoundInWindow = do ("Get start time")
	middleSoundInWindow = startSoundInWindow+halfDurationAnalysisWindow
　　#Create a power spectrum for each frame
	do ("To PowerCepstrogram...", 61, 0.002, 5000, 50)
	do ("To PowerCepstrum (slice)...", middleSoundInWindow)
　　#Subtracting Calculation Noise
	do ("Subtract tilt...", 0.001, 0, "Straight", "Robust")
　　#Calculate CPP between 60-400 Hz
　	quefrencyPeak = do ("Get quefrency of peak...", 60, 400, "Parabolic")
	frequencySoundInWindow = 1/quefrencyPeak
　　#Search for f0 using spectral waveforms at 20 Hz before and after the peak frequency of CPP
　	frequencySoundInWindowLowerSearchLimit = frequencySoundInWindow-20
	frequencySoundInWindowUpperSearchLimit = frequencySoundInWindow+20
	selectObject ("Spectrum soundInWindow")
	do ("To Ltas...", 6)
	do ("Rename...", "soundInWindow2")
	peakInFrequencyZone = do ("Get frequency of maximum...", frequencySoundInWindowLowerSearchLimit, frequencySoundInWindowUpperSearchLimit, "None")
	#Calculate each overtone number that exists within 500-1500 Hz
　 　firstHarmonicIn500to1500 = ceiling (500/peakInFrequencyZone)
	lastHarmonicIn500to1500 = floor (1500/peakInFrequencyZone)
	do ("Create Table with column names...", "peaks", 0, "peakHeight")
	selectObject ("Ltas soundInWindow")
	for p from firstHarmonicIn500to1500 to lastHarmonicIn500to1500
		selectObject ("Ltas soundInWindow")
　　　　#Extract the peak Hz of harmonics at 500-1500 Hz and their spectral dB using the f0 frequency obtained above.
		harmonicZoneLeftBoundary = (p*peakInFrequencyZone)-20
		harmonicZoneRightBoundary = (p*peakInFrequencyZone)+20
		peakInHarmonicZone = do ("Get maximum...", harmonicZoneLeftBoundary, harmonicZoneRightBoundary, "None")
		selectObject ("Table peaks")
		do ("Append row")
		numberOfRows= do ("Get number of rows")
		do ("Set numeric value...", numberOfRows, "peakHeight", peakInHarmonicZone)
	endfor
	selectObject ("Table peaks")
    #Calculate peak dB average of overtone structure at 500-1500 Hz
　	meanPeakHeight = do ("Get mean...", "peakHeight")
	firstValleyIn500to1500 = firstHarmonicIn500to1500
	lastValleyIn500to1500 = (floor (1500/frequencySoundInWindow))-1
	do ("Create Table with column names...", "valleys", 0, "valleyDepth")
	selectObject ("Ltas soundInWindow")
	for v from firstValleyIn500to1500 to lastValleyIn500to1500
		selectObject ("Ltas soundInWindow")
　　　　  #between overtones existing between 500 and 1500 Hz (the lowest dB of the valley in the region narrowed by 20 Hz between the overtone peaks is calculated).		
        valleyZoneLeftBoundary = (v*peakInFrequencyZone)+20
		valleyZoneRightBoundary = ((v+1)*peakInFrequencyZone)-20
		depthInValleyZone = do ("Get minimum...", valleyZoneLeftBoundary, valleyZoneRightBoundary, "None")
		selectObject ("Table valleys")
		do ("Append row")
		numberOfRows= do ("Get number of rows")
		do ("Set numeric value...", numberOfRows, "valleyDepth", depthInValleyZone)
	endfor
	selectObject ("Table valleys")
	meanValleyDepth = do ("Get mean...", "valleyDepth")
　　#Difference between overtone Max average and noise mindB average at 500-1500Hz
	hnrd = meanPeakHeight-meanValleyDepth
	selectObject ("Table hnrd")
	do ("Append row")
	do ("Set numeric value...", n, "hnrd", hnrd)
	




# h1-h2############################################################

	firstHarmonicLowerBoundary = peakInFrequencyZone-20
	firstHarmonicUpperBoundary = peakInFrequencyZone+20
	h2PeakInFrequencyZone = peakInFrequencyZone*2
	secondHarmonicLowerBoundary = h2PeakInFrequencyZone-20
	secondHarmonicUpperBoundary = h2PeakInFrequencyZone+20
	selectObject ("Ltas soundInWindow2")
	h1Amplitude = do ("Get maximum...", firstHarmonicLowerBoundary, firstHarmonicUpperBoundary, "None")
	h2Amplitude = do ("Get maximum...", secondHarmonicLowerBoundary, secondHarmonicUpperBoundary, "None")
	h1h2 = h1Amplitude-h2Amplitude
	selectObject ("Table h1h2")
	do ("Append row")
	do ("Set numeric value...", n, "h1h2", h1h2)

endfor

#################　End of frame analysis


	# Retrieve final results from intermediate tables

selectObject ("Table hfno")
finalhfno6000 = do ("Get mean...", "hfno6000")

selectObject ("Table hnrd")
finalhnrd = do ("Get mean...", "hnrd")

selectObject ("Table h1h2")
finalH1H2 = do ("Get mean...", "h1h2")

# Analyses on whole sound




#########################################################################
		# Slope of the long-term average spectrum　　【slope】
#########################################################################
selectObject ("Sound ari")
To Ltas... 1
slope = Get slope... 0 1000 1000 10000 energy

#########################################################################
　　　# Tilt of trendline through the long-term average spectrum　【tilt】
#########################################################################
Compute trend line... 1 10000
tilt = Get slope... 0 1000 1000 10000 energy


#########################################################################
　　　# Harmonic-to-noise ratio　【hnr】
#########################################################################
selectObject ("Sound ari")
To Pitch (cc)... 0 75 15 no 0.03 0.45 0.01 0.35 0.14 600
selectObject ("Sound ari")
plusObject ("Pitch ari")
To PointProcess (cc)
selectObject ("Sound ari")
plusObject ("Pitch ari")
plusObject ("PointProcess ari_ari")
voiceReport$ = Voice report... 0 0 75 600 1.3 1.6 0.03 0.45
hnr = extractNumber (voiceReport$, "Mean harmonics-to-noise ratio: ")

# Praat's smoothed cepstral peak prominence (cpps) ############################################################
　　
　　#Calculate CPP between 60-400 Hz
　　#▲▲However, if there are strong subharmonics within this range, errors occur in which that frequency band is detected as CPP ▲▲
　　#▲▲Also, when the overtones are extremely attenuated, as in the case of strong breathiness, the CPP itself is all low, and the error is large, so the CPP does not necessarily correspond to the first overtone.▲▲　	

selectObject ("Sound ari")
do ("To PowerCepstrogram...", 60, 0.002, 5000, 50)
cpps = do ("Get CPPS...", "no", 0.01, 0.001, 60, 330, 0.05, "Parabolic", 0.001, 0, "Straight", "Robust")


# Praat's jitter ############################################################
		
selectObject ("Sound ari")
do ("To Pitch...", 0, 70, 600)
selectObject ("Sound ari")
plusObject ("Pitch ari")
do ("To PointProcess (cc)")
selectObject ("Sound ari")
plusObject ("Pitch ari")
plusObject ("PointProcess ari_ari")
voiceReport$ = Voice report... 0 0 70 600 1.3 1.6 0.03 0.45
jitterLocalPre = extractNumber (voiceReport$, "Jitter (local): ")
jitterLocal = jitterLocalPre*100

# Praat's shimmers ############################################################

shimmerLocalPre = extractNumber (voiceReport$, "Shimmer (local): ")
shimmerLocal = shimmerLocalPre*100
shimmerLocaldB = extractNumber (voiceReport$, "Shimmer (local, dB): ")

# Natural logarithm of Praat's standard deviation of period (psd) (lnpsd)############################################################

psd = extractNumber (voiceReport$, "Standard deviation of period: ")

# Glottal-to-Noise Excitation ratio (gne)############################################################

selectObject ("Sound ari")
do ("To Harmonicity (gne)...", 500, 4500, 1000, 80)
gneMaximum = do ("Get maximum")


# Remove intermediate objects#######################################################################

select all
for sub2 from left_Sound_No. to left_Sound_No. + (number_of_patients-1)
#■Select CS Sample
minus sub2
endfor

#■Select SV Sample
for sub3 from right_Sound_No. to right_Sound_No. + (number_of_patients-1)
minus sub3
endfor

Remove








################################################################


label without_others

#################################################################
######################## Exporting calculation results　#########################
#################################################################


if draw_Results = 1
do ("Select outer viewport...", 0, 12, 8, 12)

#################################################################
######################## Calculate ARI (and ABI)　###############################
#################################################################

ari = 4.869405796723514 - 0.068586*chaoticNoise_Power_of_all + 0.107947*superSubharmonics_of_all + 0.000516*one_3rdSubharmonics_of_all + 0.017007*one_harfSubharmonics_of_all - 0.226746*finalhfno6000 - 0.023793*finalhnrd + 0.035208*cpps + 2.019074*shimmerLocaldB + 545.539678*psd - 1.054173*gneMaximum + 0.003609*slope + 0.052504*tilt
#abi =(5.0447730915-(0.172*cpps)-(0.193*jitterLocal)-(1.283*gneMaximum)-(0.396*finalhfno6000)+(0.01*finalhnrd)+(0.017*finalH1H2)+(1.473*shimmerLocaldB)-(0.088*shimmerLocal)-(68.295*psd))*2.9257400394


#appendInfoLine: ari
about$ = fixed$(ari, 2)

printline  'namecs$' 	'ari' 	'abi' 	'chaoticNoise_Power_of_all' 	'superSubharmonics_Power_of_all' 	'one_3rdSubharmonics_Power_of_all' 	'one_harfSubharmonics_Power_of_all' 	'superSubharmonics_of_all' 	'one_3rdSubharmonics_of_all' 	'one_harfSubharmonics_of_all' 	'finalhfno6000'  	'finalhnrd'  	'finalH1H2'  	'cpps' 	'jitterLocal' 	'shimmerLocal' 	'shimmerLocaldB' 	'psd' 	'gneMaximum' 	'slope' 	'tilt' 	'hnr'
fappendinfo 'save_directory$'/'title_of_table$'.xls
clearinfo
#################################################################
############## Start drawing calculation results to Innner Viewport　#################
#################################################################

# Data display part
    Font size... 9
    Select inner viewport... 0.5 5.5 9.5 11.6
    Draw inner box
    Axes... 0 10 10 0
    Text... 0.05 Left 0.9 Half 1/2 Subharmonics:##'one_harfSubharmonics_of_all:3' #
    Text... 0.05 Left 1.6 Half 1/3 Subharmonics:##'one_3rdSubharmonics_of_all:3' #
    Text... 0.05 Left 2.3 Half 1/n Subharmonics:##'superSubharmonics_of_all:3' #
    Text... 0.05 Left 3.0 Half Chaotic noise:##'chaoticNoise_Power_of_all:3' #
 
    Text... 0.05 Left 4.1 Half Smoothed cepstral peak prominence (CPPS): ##'cpps:3' dB#
    Text... 0.05 Left 4.8 Half Glottal-to-Noise Excitation ratio (4.5 kHz freq-max): ##'gneMaximum:3'#
    Text... 0.05 Left 5.5 Half High Frequency Noise of 6000 Hz: ##'finalhfno6000:3' dB#
    Text... 0.05 Left 6.2 Half Harmonics-to-Noise Ratio of Dejonckere: ##'finalhnrd:3' dB#
    Text... 0.05 Left 6.9 Half Shimmer local dB: ##'shimmerLocaldB:3' dB#
    Text... 0.05 Left 7.6 Half Period standard deviation: ##'psd:5' sec#
    Text... 0.05 Left 8.3 Half Slope of the long-term average spectrum: ##'slope:3' #
    Text... 0.05 Left 9.0 Half Tilt of trendline through the long-term average spectrum: ##'tilt:3' #




#Drawing part of ARI
    Select inner viewport...  6.5 11.5 10.3 11.0
    Draw inner box
    Axes... 0 10 1 0
    Marks top every... 1 1 yes yes no
    Draw inner box
    Paint rectangle... cyan 0 2.087753 0 1 
    Paint rectangle... red 2.087753 10 0 1 

if ari<> undefined
    Select inner viewport... 6.5 11.5 10.3 11.0
    Arrow size... 2
　　Draw arrow... ari 1 ari 0  
endif

    #Draw arrows based on ARI scores ● Add ari calculation results
    Font size... 25
    Select inner viewport... 6.5 11.5 9.5 10.0
    Axes... 0 10 1 0
    Text... 5 Centre 0.5 Half ARI: ##'about$'#


goto skipABI
#Drawing part of ABI
    Font size... 9
    Select inner viewport... 6.5 11.5 10.9 11.6
    Draw inner box
    Axes... 0 10 1 0
    Marks top every... 1 1 yes yes no
    Draw inner box
    Paint rectangle... cyan 0 3.44 0 1 
    Paint rectangle... red 3.44 10 0 1 

if abi<> undefined
    Select inner viewport... 6.5 11.5 10.9 11.6
    Arrow size... 2
　　Draw arrow... abi 1 abi 0  
endif

    #Draw arrows based on ABI scores ●Add abi calculation results
    Font size... 16
    Select inner viewport... 6.5 11.5 10.3 10.8
    Axes... 0 10 1 0
    Text... 5 Centre 0.5 Half ABI: ##'abi:2'#
label skipABI


endif

#################################################################
############## Finish drawing calculation results to Innner Viewport　#################
#################################################################



if draw_Results = 1
    do ("Select outer viewport...", 0, 12, 0, 12)
    do ("Save as 300-dpi PNG file...", "'save_directory$'\Result'namecs$'.png")
else
    do ("Select outer viewport...", 0, 12, 0, 8)
    do ("Save as 300-dpi PNG file...", "'save_directory$'\Result'namecs$'.png")
endif



endfor

#################################################
exitScript: "Finished!!!!"
